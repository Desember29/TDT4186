package round_robin;

import java.util.LinkedList;

/**
 * This class implements functionality associated with
 * the CPU unit of the simulated system.
 */
public class Cpu {
	private Process activeProcess = null;
	
	private LinkedList<Process> cpuQueue;
	private long maxCpuTime;
	private Statistics statistics;
	
    /**
     * Creates a new CPU with the given parameters.
     * @param cpuQueue		The CPU queue to be used.
     * @param maxCpuTime	The Round Robin time quant to be used.
     * @param statistics	A reference to the statistics collector.
     */
    public Cpu(LinkedList<Process> cpuQueue, long maxCpuTime, Statistics statistics) {
    	//Initialize member variables so they can be used within class.
        this.cpuQueue = cpuQueue;
        this.maxCpuTime = maxCpuTime;
        this.statistics = statistics;
    }

    /**
     * Adds a process to the CPU queue, and activates (switches in) the first process
     * in the CPU queue if the CPU is idle.
     * @param p		The process to be added to the CPU queue.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event insertProcess(Process p, long clock) {
        cpuQueue.add(p);
        //Update process nofTimesInReadyQueue variable.
        p.addToCpuQueue(clock);
        //Check if current cpuQueue length is larger then cpuQueueLargestLength and if it is update value with current cpuQueue length.
        if (statistics.cpuQueueLargestLength < cpuQueue.size()) {
        	statistics.cpuQueueLargestLength = cpuQueue.size();
        }
        //Check if there is no activeProcess.
        if (activeProcess == null) {
        	//Switch in the first process if there is no activeProcess.
        	return switchProcess(clock);
        }
    	//If no process was activated return null.
        return null;
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event switchProcess(long clock) {
    	//Update totalBusyCpuTime
    	//Check if cpuQueue has a process waiting for CPU.
    	if (!cpuQueue.isEmpty()) {
    		//Make sure there was an activeProcess before attempting to remove process from CPU and adding it to cpuQueue.
    		if (activeProcess != null) {
    			//Update process cpuTimeNeeded, timeSpentInCpu and nofTimesInReadyQueue variables.
    			activeProcess.exitCpuEnterQueue(clock);
    			//Add the process previously active in CPU to the cpuQueue.
    			cpuQueue.add(activeProcess);
    			//Update totalBusyCpuTime variable.
    			statistics.totalBusyCpuTime += clock - activeProcess.getTimeOfLastEvent();
    		}
    		//Set activeProcess as first process in cpuQueue.
    		activeProcess = cpuQueue.pop();
        	//Update process timeSpentInReadyQueue and timeOfLastEvent variable.
    		activeProcess.enterCpu(clock);
    		//Update nofProcessSwitches variable.
    		statistics.nofProcessSwitches++;
    		//Generate new event depending on process variables.
    		return generateEvent(activeProcess, clock);
    	}
    	//If no process was activated return null.
    	return null;
    }

    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     * @return	The event generated by the process switch, or null if no new
     *			process was switched in.
     */
    public Event activeProcessLeft(long clock) {
		//Update totalBusyCpuTime variable.
		//Update process cpuTimeNeeded, timeSpentInCpu and timeOfLastEvent variables. 
		activeProcess.exitCpu(clock);
		//Update totalBusyCpuTime variable.
		statistics.totalBusyCpuTime += clock - activeProcess.getTimeOfLastEvent();
    	//Remove active process.
    	activeProcess = null;
    	//Check if cpuQueue has a process waiting for CPU.
    	if (!cpuQueue.isEmpty()) {
        	//Switch in the first process if there is processes still waiting for CPU.
    		return switchProcess(clock);
    	}
    	//If no new process was switched in return null.
    	return null;
    }

    /**
     * Returns the process currently using the CPU.
     * @return	The process currently using the CPU.
     */
    public Process getActiveProcess() {
    	//Return the activeProcess.
        return activeProcess;
    }

    /**
     * This method is called when a discrete amount of time has passed.
     * @param timePassed	The amount of time that has passed since the last call to this method.
     */
    public void timePassed(long timePassed) {
    	//Update cpuQueueLengthTime statistics whenever timePassed function is called.
        statistics.cpuQueueLengthTime += cpuQueue.size() * timePassed;
    }
    
    //Generates events for processes in the CPU segment of the system, depending on their variables.
    public Event generateEvent(Process p, long clock) {
    	//If the process requires more CPU time to complete processing than maxCpuTime and the process has a longer time to next I/O operation than maxCpuTime set SWITCH_PROCESS as new event.
    	if (maxCpuTime < p.getCpuTimeNeeded() && maxCpuTime < p.getTimeToNextIoOperation()) {
    		//Return new SWITCH_PROCESS event with occurrence time as clock + maxCpuTime.
    		return new Event(Event.SWITCH_PROCESS, clock + maxCpuTime);
    	}
    	//If the process requires less time to finish processing than the time until next I/O operation and the process requires less time to finish processing than maxCpuTime set END_PROCESS as new event.
    	else if (p.getCpuTimeNeeded() < p.getTimeToNextIoOperation()) {
    		//Return new SWITCH_PROCESS event with occurrence time as clock + cpuTimeNeeded.
    		return new Event(Event.END_PROCESS, clock + p.getCpuTimeNeeded());
    	}
    	//If the process has less time until next I/O operation than CPU time needed and the process has less time until next I/O operation than maxCpuTime set IO_REQUEST as new event.
    	else {
    		//Return new SWITCH_PROCESS event with occurrence time as clock + timeToNextIoOperation.
    		return new Event(Event.IO_REQUEST, clock + p.getTimeToNextIoOperation());
    	}
    }
}
